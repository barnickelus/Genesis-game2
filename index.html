<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Genesis Evolution — Star-Frenzy (Full Game)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
        rel="stylesheet" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #060616;
      font-family: "Inter", Arial, sans-serif;
    }
    canvas#game {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: block;
      touch-action: none;
    }
    #dragonHead {
      position: absolute;
      pointer-events: none;
      z-index: 3;
    }
    #headCanvas {
      display: block;
    }
    #hud, #compass, #effBar, #pauseBtn, #radarWrap, #zoomSlider, #joystick {
      position: fixed;
      z-index: 2;
    }
    #hud {
      top: 14px;
      left: 18px;
      color: #fff;
      font-size: 18px;
      text-shadow: 0 0 4px rgba(255, 255, 255, 0.5);
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 12px;
      border-radius: 6px;
    }
    #compass {
      top: 70px;
      left: 18px;
      color: #ccc;
      font-size: 14px;
      line-height: 14px;
      letter-spacing: 1px;
      text-shadow: 0 0 3px #000;
      background: rgba(0, 0, 0, 0.5);
      padding: 6px 10px;
      border-radius: 4px;
    }
    #effBar {
      bottom: 14px;
      left: 18px;
      width: 220px;
      height: 18px;
      border-radius: 9px;
      background: rgba(255, 255, 255, 0.12);
    }
    #effFill {
      width: 100%;
      height: 100%;
      border-radius: 9px;
      background: #00e4b8;
    }
    #pauseBtn {
      top: 14px;
      right: 18px;
      font-size: 22px;
      color: #fff;
      cursor: pointer;
      user-select: none;
    }
    #radarWrap {
      top: 48px;
      right: 18px;
      width: 70px;
      height: 70px;
      display: none;
    }
    #radar {
      width: 70px;
      height: 70px;
      border: 1px solid #555;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.4);
    }
    #zoomSlider {
      top: 130px;
      right: 18px;
      width: 70px;
      transform: rotate(-90deg);
    }
    #joystick {
      bottom: 20px;
      right: 20px;
      width: 100px;
      height: 100px;
      display: none;
    }
    #joystickCanvas {
      width: 100px;
      height: 100px;
    }
    #pauseMenu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      z-index: 3;
      display: none;
      text-align: center;
    }
    #pauseMenu button {
      display: block;
      margin: 10px auto;
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 5px;
    }
    #pauseMenu button:hover {
      background: #555;
    }
    .high-contrast #game, .high-contrast body {
      filter: contrast(1.5) brightness(1.2);
    }
    .high-contrast #hud, .high-contrast #compass {
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="dragonHead">
    <canvas id="headCanvas"></canvas>
  </div>
  <div id="hud">
    Mass: <span id="mass">10</span>&nbsp;
    Score: <span id="score">0</span>&nbsp;
    <span id="level">1</span>
  </div>
  <div id="compass">
    N<br/>E&nbsp;&nbsp;W<br/>&nbsp;S
  </div>
  <div id="effBar"><div id="effFill"></div></div>
  <div id="pauseBtn">⏸︎</div>
  <div id="radarWrap">
    <canvas id="radar" width="70" height="70"></canvas>
  </div>
  <input id="zoomSlider" type="range" min="0.5" max="2" step="0.01" value="1" />
  <div id="joystick">
    <canvas id="joystickCanvas" width="100" height="100"></canvas>
  </div>
  <div id="pauseMenu">
    <h2>Paused</h2>
    <button id="resumeBtn">Resume</button>
    <button id="restartBtn">Restart</button>
    <button id="muteBtn">Mute Audio</button>
    <button id="radarToggleBtn">Toggle Radar</button>
    <button id="contrastBtn">Enable High Contrast</button>
  </div>
  <audio id="backgroundMusic" src="background-music.mp3" loop preload="auto"></audio>
  <audio id="eatSnd" src="eat.mp3" preload="auto"></audio>
  <audio id="hurtSnd" src="hurt.mp3" preload="auto"></audio>
  <audio id="frenzySnd" src="frenzy.mp3" preload="auto"></audio>

  <script>
    window.TILE  = 48;
    window.SCALE = 4;
    window.COLS  = 32;
    window.ROWS  = 5;
  </script>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/loaders/GLTFLoader.js';

    console.log("MODULE SCRIPT STARTED");

    const TILE  = window.TILE,
          SCALE = window.SCALE;

    const headCanvas = document.getElementById('headCanvas');
    const renderer   = new THREE.WebGLRenderer({ canvas: headCanvas, alpha: true, antialias: true });
    renderer.setSize(TILE * SCALE, TILE * SCALE);

    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
    camera.position.set(0, 0, 5);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(1, 2, 3);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));

    let headMesh = null;
    new GLTFLoader().load(
      'dragon-head.glb',
      gltf => {
        headMesh = gltf.scene;
        const box = new THREE.Box3().setFromObject(headMesh);
        const size = box.getSize(new THREE.Vector3()).length();
        const norm = 2 / size;
        headMesh.scale.setScalar(norm);
        box.setFromObject(headMesh);
        const ctr = box.getCenter(new THREE.Vector3()).negate();
        headMesh.position.copy(ctr);
        headMesh.rotation.order = 'YXZ';
        scene.add(headMesh);
        console.log("%c✔ 3-D head loaded & centred", "color:#0f0");
      },
      undefined,
      err => console.error("GLTF load error:", err)
    );

    window.renderHead = (yaw, pitch) => {
      if (!headMesh) return;
      headMesh.rotation.y = yaw;
      headMesh.rotation.x = pitch;
      renderer.render(scene, camera);
    };
  </script>

  <script>
    console.log("MAIN SCRIPT STARTED");

    const TILE  = window.TILE,
          SCALE = window.SCALE,
          COLS  = window.COLS,
          ROWS  = window.ROWS;

    const canvas = document.getElementById('game'),
          ctx    = canvas.getContext('2d', { alpha: false });
    ctx.imageSmoothingEnabled = false;

    let W, H;
    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }
    function resize() {
      W = canvas.width = innerWidth;
      H = canvas.height = innerHeight;
    }
    window.addEventListener('resize', debounce(resize, 100));
    resize();

    const massEl   = document.getElementById('mass'),
          scoreEl  = document.getElementById('score'),
          levelEl  = document.getElementById('level'),
          pauseBtn = document.getElementById('pauseBtn'),
          radarC   = document.getElementById('radar'),
          rctx     = radarC.getContext('2d'),
          joystickCanvas = document.getElementById('joystickCanvas'),
          jctx     = joystickCanvas ? joystickCanvas.getContext('2d') : null,
          pauseMenu = document.getElementById('pauseMenu'),
          resumeBtn = document.getElementById('resumeBtn'),
          restartBtn = document.getElementById('restartBtn'),
          muteBtn   = document.getElementById('muteBtn'),
          radarToggleBtn = document.getElementById('radarToggleBtn'),
          contrastBtn = document.getElementById('contrastBtn');

    const MASS_THRESH       = 600,
          TITAN_LEVEL       = 10,
          TITAN_MAX         = 6,
          TITAN_RESPAWN_MS  = 20000,
          SPECTRE_MAX       = 3,
          REAPER_MAX        = 3,
          C_RING_DIST       = 1600,
          SPECTRE_SPEED_MS  = 6000,
          SPECTRE_SPEED_MULT= 1.25,
          RADAR_PADDING     = 4,
          ZOOM_EASE         = 0.25,
          MASS_SPEED_FACTOR = 0.0012,
          EXTRA_TAIL_PCT    = 0.10,
          MAX_TAIL_DRAW     = 60,
          SAFE_PLAYER_MASS  = 70,
          BLINK_MS          = 300,
          SHIELD_DURATION   = 5000,
          BASE_FOE_COUNT    = 12,
          BASE_TITAN_COUNT  = 3,
          BASE_SPECTRE_COUNT= 2,
          BASE_REAPER_COUNT = 1;

    let sliderZoom = 1, zoom = 1;
    document.getElementById('zoomSlider').oninput = e =>
      sliderZoom = parseFloat(e.target.value);

    const rand = v => Math.random() * v - v / 2;
    const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
    const lerp = (a, b, t) => a + (b - a) * t;
    const rgb  = h => ({
      r: parseInt(h.slice(1, 3), 16),
      g: parseInt(h.slice(3, 5), 16),
      b: parseInt(h.slice(5, 7), 16)
    });
    const mix  = (a, b, t) => {
      const A = rgb(a), B = rgb(b);
      return `rgb(${Math.round(lerp(A.r, B.r, t))},
                   ${Math.round(lerp(A.g, B.g, t))},
                   ${Math.round(lerp(A.b, B.b, t))})`;
    };

    const food      = [],
          foes      = [],
          titans    = [],
          spectres  = [],
          reapers   = [],
          beacons   = [],
          particles = [],
          headParticles = [],
          playerAuraParticles = [];

    let player = {
      x: 0, y: 0, r: 15, mass: 10, tail: [],
      baseSpeed: 2.5, blink: 0, speedBoost: 0, heading: 0,
      colorEffect: { color: '#00e4b8', t: 0 }
    },
    target = { x: 0, y: 0, active: false },
    offset = { x: 0, y: 0 },
    pill = { x: 0, y: 0, r: 10, active: false, cd: 0 },
    shield = { x: 0, y: 0, r: 10, active: false, cd: 0 },
    frenzy = false, F_TIME = 0, paused = false, radarActive = false,
    titanTimer = 0, titanKill = 0, spectreKill = 0, level = 1,
    shieldActive = false, shieldTime = 0, isMuted = false,
    joystickActive = false, joystickX = 0, joystickY = 0;

    const STARS = 120,
          stars = Array.from({ length: STARS }, () => ({
            x: rand(4000), y: rand(4000), s: Math.random() * 1.5 + 0.5
          }));

    const spawnFood = () => {
      while (food.length < 60) food.push({ x: rand(1800), y: rand(1800), r: 6 });
    };
    const spawnFoe = () => {
      foes.push({
        x: rand(2000), y: rand(2000),
        r: (player.mass >= MASS_THRESH ? 14 : 10) + Math.random() * 20
      });
    };
    const spawnTitan = () => {
      const a = Math.random() * Math.PI * 2,
            d = 700 + Math.random() * 500;
      titans.push({
        x: player.x + Math.cos(a) * d,
        y: player.y + Math.sin(a) * d,
        r: 25 + Math.random() * 35,
        hop: 0
      });
    };
    const spawnSpectre = () => {
      const a = Math.random() * Math.PI * 2,
            d = 600 + Math.random() * 400;
      spectres.push({
        x: player.x + Math.cos(a) * d,
        y: player.y + Math.sin(a) * d,
        r: 22 + Math.random() * 25,
        dash: 0
      });
    };
    const spawnReaper = () => {
      const a = Math.random() * Math.PI * 2,
            d = 800 + Math.random() * 600;
      reapers.push({
        x: player.x + Math.cos(a) * d,
        y: player.y + Math.sin(a) * d,
        r: 38 + Math.random() * 28,
        charge: 0
      });
    };
    const spawnPill = () => {
      pill = { x: rand(1800), y: rand(1800), r: 10, active: true, cd: 0 };
    };
    const spawnShield = () => {
      shield = { x: rand(1800), y: rand(1800), r: 10, active: true, cd: 0 };
    };

    spawnFood();
    for (let i = 0; i < BASE_FOE_COUNT; i++) spawnFoe();
    ['N', 'S', 'E', 'W'].forEach(d => {
      const P = { N: [0, -C_RING_DIST], S: [0, C_RING_DIST], E: [C_RING_DIST, 0], W: [-C_RING_DIST, 0] }[d];
      beacons.push({ x: P[0], y: P[1], r: 18 });
    });

    function toWorld(e) {
      return { x: (e.clientX - offset.x) / zoom, y: (e.clientY - offset.y) / zoom };
    }
    canvas.onpointerdown = e => {
      if (paused) return;
      const p = toWorld(e);
      target = { x: p.x, y: p.y, active: true };
    };
    canvas.onpointermove = e => {
      if (target.active && !paused) {
        const p = toWorld(e);
        target.x = p.x;
        target.y = p.y;
      }
    };
    canvas.onpointerup = () => target.active = false;

    pauseBtn.onclick = () => {
      paused = !paused;
      pauseBtn.textContent = paused ? '▶︎' : '⏸︎';
      pauseMenu.style.display = paused ? 'block' : 'none';
      const bg = document.getElementById('backgroundMusic');
      if (bg && !isMuted) paused ? bg.pause() : bg.play().catch(() => {});
    };

    resumeBtn.onclick = () => {
      paused = false;
      pauseBtn.textContent = '⏸︎';
      pauseMenu.style.display = 'none';
      const bg = document.getElementById('backgroundMusic');
      if (bg && !isMuted) bg.play().catch(() => {});
    };

    restartBtn.onclick = () => {
      player = { x: 0, y: 0, r: 15, mass: 10, tail: [], baseSpeed: 2.5, blink: 0, speedBoost: 0, heading: 0, colorEffect: { color: '#00e4b8', t: 0 } };
      food.length = 0;
      foes.length = 0;
      titans.length = 0;
      spectres.length = 0;
      reapers.length = 0;
      beacons.length = 0;
      particles.length = 0;
      headParticles.length = 0;
      playerAuraParticles.length = 0;
      target = { x: 0, y: 0, active: false };
      pill = { x: 0, y: 0, r: 10, active: false, cd: 0 };
      shield = { x: 0, y: 0, r: 10, active: false, cd: 0 };
      frenzy = false;
      F_TIME = 0;
      paused = false;
      radarActive = false;
      titanTimer = 0;
      titanKill = 0;
      spectreKill = 0;
      level = 1;
      shieldActive = false;
      shieldTime = 0;
      joystickActive = false;
      joystickX = 0;
      joystickY = 0;
      document.getElementById('radarWrap').style.display = 'none';
      pauseMenu.style.display = 'none';
      pauseBtn.textContent = '⏸︎';
      spawnFood();
      for (let i = 0; i < BASE_FOE_COUNT; i++) spawnFoe();
      ['N', 'S', 'E', 'W'].forEach(d => {
        const P = { N: [0, -C_RING_DIST], S: [0, C_RING_DIST], E: [C_RING_DIST, 0], W: [-C_RING_DIST, 0] }[d];
        beacons.push({ x: P[0], y: P[1], r: 18 });
      });
    };

    muteBtn.onclick = () => {
      isMuted = !isMuted;
      muteBtn.textContent = isMuted ? 'Unmute Audio' : 'Mute Audio';
      const bg = document.getElementById('backgroundMusic');
      if (bg) bg.muted = isMuted;
      ['eatSnd', 'hurtSnd', 'frenzySnd'].forEach(id => {
        const snd = document.getElementById(id);
        if (snd) snd.muted = isMuted;
      });
    };

    radarToggleBtn.onclick = () => {
      radarActive = !radarActive;
      document.getElementById('radarWrap').style.display = radarActive ? 'block' : 'none';
    };

    contrastBtn.onclick = () => {
      document.body.classList.toggle('high-contrast');
      contrastBtn.textContent = document.body.classList.contains('high-contrast') ? 'Disable High Contrast' : 'Enable High Contrast';
    };

    function drawJoystick() {
      if (!jctx) return;
      jctx.clearRect(0, 0, 100, 100);
      jctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
      jctx.beginPath();
      jctx.arc(50, 50, 50, 0, Math.PI * 2);
      jctx.fill();
      if (joystickActive) {
        jctx.fillStyle = '#00e4b8';
        jctx.beginPath();
        jctx.arc(50 + joystickX * 30, 50 + joystickY * 30, 20, 0, Math.PI * 2);
        jctx.fill();
      }
    }

    joystickCanvas?.addEventListener('touchstart', (e) => {
      if (paused) return;
      e.preventDefault();
      const touch = e.touches[0];
      const rect = joystickCanvas.getBoundingClientRect();
      joystickX = (touch.clientX - rect.left - 50) / 50;
      joystickY = (touch.clientY - rect.top - 50) / 50;
      const len = Math.hypot(joystickX, joystickY);
      if (len > 1) {
        joystickX /= len;
        joystickY /= len;
      }
      joystickActive = true;
      target.active = true;
    });

    joystickCanvas?.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = joystickCanvas.getBoundingClientRect();
      joystickX = (touch.clientX - rect.left - 50) / 50;
      joystickY = (touch.clientY - rect.top - 50) / 50;
      const len = Math.hypot(joystickX, joystickY);
      if (len > 1) {
        joystickX /= len;
        joystickY /= len;
      }
    });

    joystickCanvas?.addEventListener('touchend', () => {
      joystickActive = false;
      joystickX = 0;
      joystickY = 0;
      target.active = false;
    });

    if (/Mobi|Android/i.test(navigator.userAgent)) {
      document.getElementById('joystick').style.display = 'block';
    }

    function onScreen(x, y, r) {
      return !(x + r < player.x - W / (2 * zoom) ||
               x - r > player.x + W / (2 * zoom) ||
               y + r < player.y - H / (2 * zoom) ||
               y - r > player.y + H / (2 * zoom));
    }
    function glow(x, y, r, c, a, shadowBlur = 12 * zoom) {
      if (r * zoom < 0.8 || !onScreen(x, y, r)) return;
      ctx.globalAlpha = a;
      ctx.shadowBlur = shadowBlur;
      ctx.shadowColor = c;
      ctx.fillStyle = c;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }
    function burst(x, y, c) {
      for (let i = 0; i < 12; i++) {
        particles.push({
          x, y,
          dx: rand(2),
          dy: rand(2),
          r: 2 + Math.random() * 2,
          ttl: 500 + Math.random() * 200,
          col: c,
          shape: Math.random() < 0.5 ? 'circle' : 'square'
        });
      }
    }
    function drawRadar() {
      rctx.clearRect(0, 0, 70, 70);
      rctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      rctx.fillRect(0, 0, 70, 70);
      rctx.fillStyle = '#fff';
      rctx.beginPath();
      rctx.arc(35, 35, 2, 0, Math.PI * 2);
      rctx.fill();

      const radarRange = 2000, scale = 66 / (radarRange * 2);
      food.forEach(f => {
        const dx = (f.x - player.x) * scale + 35,
              dy = (f.y - player.y) * scale + 35;
        if (dx < 2 || dx > 68 || dy < 2 || dy > 68) return;
        rctx.fillStyle = f.frenzy ? f.col : '#ff0';
        rctx.beginPath();
        rctx.arc(dx, dy, 1, 0, Math.PI * 2);
        rctx.fill();
      });
      foes.forEach(o => {
        const dx = (o.x - player.x) * scale + 35,
              dy = (o.y - player.y) * scale + 35;
        if (dx < 2 || dx > 68 || dy < 2 || dy > 68) return;
        rctx.fillStyle = '#f00';
        rctx.beginPath();
        rctx.arc(dx, dy, 1, 0, Math.PI * 2);
        rctx.fill();
      });
      titans.forEach(o => {
        const dx = (o.x - player.x) * scale + 35,
              dy = (o.y - player.y) * scale + 35;
        if (dx < 2 || dx > 68 || dy < 2 || dy > 68) return;
        rctx.fillStyle = '#cc00ff';
        rctx.beginPath();
        rctx.arc(dx, dy, 1.5, 0, Math.PI * 2);
        rctx.fill();
      });
      spectres.forEach(s => {
        const dx = (s.x - player.x) * scale + 35,
              dy = (s.y - player.y) * scale + 35;
        if (dx < 2 || dx > 68 || dy < 2 || dy > 68) return;
        rctx.fillStyle = '#ff39ff';
        rctx.beginPath();
        rctx.arc(dx, dy, 1.5, 0, Math.PI * 2);
        rctx.fill();
      });
      reapers.forEach(r => {
        const dx = (r.x - player.x) * scale + 35,
              dy = (r.y - player.y) * scale + 35;
        if (dx < 2 || dx > 68 || dy < 2 || dy > 68) return;
        rctx.fillStyle = '#ff8800';
        rctx.beginPath();
        rctx.arc(dx, dy, 1.5, 0, Math.PI * 2);
        rctx.fill();
      });
      if (pill.active) {
        const dx = (pill.x - player.x) * scale + 35,
              dy = (pill.y - player.y) * scale + 35;
        if (dx >= 2 && dx <= 68 && dy >= 2 && dy <= 68) {
          rctx.fillStyle = '#00aaff';
          rctx.beginPath();
          rctx.arc(dx, dy, 1.5, 0, Math.PI * 2);
          rctx.fill();
        }
      }
      if (shield.active) {
        const dx = (shield.x - player.x) * scale + 35,
              dy = (shield.y - player.y) * scale + 35;
        if (dx >= 2 && dx <= 68 && dy >= 2 && dy <= 68) {
          rctx.fillStyle = '#ffd700';
          rctx.beginPath();
          rctx.arc(dx, dy, 1.5, 0, Math.PI * 2);
          rctx.fill();
        }
      }
      beacons.forEach(b => {
        const dx = (b.x - player.x) * scale + 35,
              dy = (b.y - player.y) * scale + 35;
        if (dx < 2 || dx > 68 || dy < 2 || dy > 68) return;
        rctx.fillStyle = '#fff';
        rctx.beginPath();
        rctx.arc(dx, dy, 1.5, 0, Math.PI * 2);
        rctx.fill();
      });
    }
    function drawGrid() {
      const step = zoom <= 0.8 ? 60 : 120;
      ctx.lineWidth = 1.2;
      for (let z = 0; z < 6; z++) {
        const s = 1 + z * 0.15, opa = 0.8 - 0.12 * z;
        ctx.strokeStyle = `rgba(34,34,34,${opa})`;
        for (let i = -4; i <= 4; i++) {
          for (let j = -4; j <= 4; j++) {
            const x = i * step * s, y = j * step * s;
            if (!onScreen(x, y, step * s * 1.4)) continue;
            ctx.beginPath();
            ctx.rect(x, y, step * s, step * s);
            ctx.stroke();
          }
        }
      }
    }
    function updateHead(sx, sy, yIdx, pIdx, zf) {
      const wrap = document.getElementById('dragonHead'),
            size = window.TILE * window.SCALE * zf;
      wrap.style.width = size + 'px';
      wrap.style.height = size + 'px';
      wrap.style.left = sx - size / 2 + 'px';
      wrap.style.top = sy - size / 2 + 'px';
      const cvs = document.getElementById('headCanvas');
      cvs.style.width = size + 'px';
      cvs.style.height = size + 'px';
      if (typeof window.renderHead === 'function') {
        window.renderHead((yIdx / COLS) * 2 * Math.PI,
                          ((pIdx / (ROWS - 1)) - 0.5) * Math.PI);
      }
    }

    function unlockAudio() {
      const bg = document.getElementById('backgroundMusic');
      if (bg && bg.paused && !isMuted) {
        bg.play().catch(() => {});
      }
    }
    addEventListener('touchstart', unlockAudio, { once: true });
    addEventListener('pointerdown', unlockAudio, { once: true });

    let last = 0;
    function loop(ts) {
      if (paused) { last = ts; requestAnimationFrame(loop); return; }
      const dt = (ts - last) || 16; last = ts;

      zoom = lerp(zoom, Math.min(sliderZoom, Math.max(0.5, H / (player.r * 4))), ZOOM_EASE);
      const dx = (target.active ? target.x : player.x) - player.x,
            dy = (target.active ? target.y : player.y) - player.y,
            dLen = Math.hypot(dx, dy);
      if (joystickActive) {
        target.x = player.x + joystickX * 100;
        target.y = player.y + joystickY * 100;
      }
      if (dLen > 0.5) player.heading = Math.atan2(dy, dx);
      if (player.speedBoost > 0) player.speedBoost = Math.max(0, player.speedBoost - dt);
      const speed = player.baseSpeed *
                    (player.speedBoost > 0 ? SPECTRE_SPEED_MULT : 1) *
                    (frenzy ? 1.3 : 1) *
                    (1 + player.mass * MASS_SPEED_FACTOR);
      if (dLen > 1) { player.x += dx / dLen * speed; player.y += dy / dLen * speed; }

      player.mass = Math.max(5,
        player.mass - (0.000009 * player.r * player.r + (player.mass < 150 ? 0.002 : 0.003)) * dt
      );

      if (player.colorEffect.t > 0) {
        player.colorEffect.t -= dt;
        if (player.colorEffect.t <= 0) player.colorEffect.color = '#00e4b8';
      }

      offset.x = W / 2 - player.x * zoom;
      offset.y = H / 2 - player.y * zoom;

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#060616'; ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = '#222';
      for (const s of stars) {
        const sx = (s.x - player.x * 0.1) * zoom + offset.x,
              sy = (s.y - player.y * 0.1) * zoom + offset.y;
        if (sx < 0 || sx > W || sy < 0 || sy > H) continue;
        ctx.fillRect(sx, sy, s.s, s.s);
      }
      ctx.setTransform(zoom, 0, 0, zoom, offset.x, offset.y);
      drawGrid();

      food.forEach((f, i) => {
        if (!onScreen(f.x, f.y, f.r)) return;
        if (dist(player.x, player.y, f.x, f.y) < player.r + f.r) {
          player.mass += f.r;
          player.colorEffect = { color: f.frenzy ? f.col : '#ff0', t: 500 };
          food.splice(i, 1);
          burst(f.x, f.y, '#ff0');
          document.getElementById('eatSnd').play().catch(() => {});
        } else {
          glow(f.x, f.y, f.r, f.frenzy ? f.col : '#ff0', f.frenzy ? 0.8 : 0.65);
        }
      });
      spawnFood();

      while (foes.length < BASE_FOE_COUNT + Math.floor(level / 5)) spawnFoe();
      foes.forEach((o, i) => {
        if (!onScreen(o.x, o.y, o.r)) return;
        const d = dist(player.x, player.y, o.x, o.y);
        if (o.r < player.r && d < player.r) {
          player.mass += o.r * 2.5;
          player.colorEffect = { color: '#f00', t: 500 };
          foes.splice(i, 1);
          burst(o.x, o.y, '#f00');
          document.getElementById('eatSnd').play().catch(() => {});
          return;
        }
        if (!shieldActive && o.r > player.r && d < o.r) {
          if (player.blink < 50) player.blink = BLINK_MS;
          player.mass = Math.max(5, player.mass - 0.04 * dt);
          document.getElementById('hurtSnd').play().catch(() => {});
        }
        const c = 1;
        if (o.r < player.r && d < 250) {
          o.x -= (player.x - o.x) / d * c; o.y -= (player.y - o.y) / d * c;
        } else if (o.r > player.r && d < 250) {
          o.x += (player.x - o.x) / d * c; o.y += (player.y - o.y) / d * c;
        }
        glow(o.x, o.y, o.r, '#f00', 0.8);
      });

      if (level >= TITAN_LEVEL) {
        while (titans.length < Math.min(TITAN_MAX, BASE_TITAN_COUNT + Math.floor((level - TITAN_LEVEL) / 5))) spawnTitan();
        titanTimer += dt;
        if (titanTimer > TITAN_RESPAWN_MS) { titanTimer = 0; titans.length = 0; }
      }
      titans.forEach((o, i) => {
        if (!onScreen(o.x, o.y, o.r)) return;
        const d = dist(player.x, player.y, o.x, o.y);
        if (d > 2000) { titans.splice(i, 1); spawnTitan(); return; }
        if (player.r > o.r && d < player.r) {
          player.mass += o.r * 5;
          player.colorEffect = { color: '#cc00ff', t: 500 };
          titans.splice(i, 1); titanKill++;
          burst(o.x, o.y, '#cc00ff');
          return;
        }
        if (!shieldActive && o.r > player.r && d < o.r) {
          if (player.blink < 50) player.blink = BLINK_MS;
          player.mass = Math.max(5, player.mass - 0.1 * dt);
          document.getElementById('hurtSnd').play().catch(() => {});
        }
        o.hop -= dt;
        if (o.hop <= 0) {
          o.hop = 700;
          const hop = o.r > player.r ? 120 : -80;
          o.x += (player.x - o.x) / d * hop; o.y += (player.y - o.y) / d * hop;
        }
        glow(o.x, o.y, o.r, '#cc00ff', 0.9);
      });

      if (titanKill >= 10) {
        while (spectres.length < Math.min(SPECTRE_MAX, BASE_SPECTRE_COUNT + Math.floor(titanKill / 10))) spawnSpectre();
      }
      spectres.forEach((s, i) => {
        if (!onScreen(s.x, s.y, s.r)) return;
        s.dash -= dt;
        const d = dist(player.x, player.y, s.x, s.y),
              ignore = player.mass < SAFE_PLAYER_MASS;
        if (d > 2200) { spectres.splice(i, 1); spawnSpectre(); return; }
        if (!ignore && d < player.r) {
          player.mass += s.r * 7;
          player.colorEffect = { color: '#ff39ff', t: 500 };
          player.speedBoost = SPECTRE_SPEED_MS;
          spectres.splice(i, 1); document.getElementById('eatSnd').play().catch(() => {});
          spectreKill++;
          if (spectreKill % 6 === 0 && reapers.length < REAPER_MAX) spawnReaper();
          return;
        }
        if (!ignore && !shieldActive && d < s.r && s.r > player.r) {
          if (player.blink < 50) player.blink = BLINK_MS;
          player.mass = Math.max(5, player.mass - 0.2 * dt);
          document.getElementById('hurtSnd').play().catch(() => {});
        }
        if (s.dash <= 0) {
          s.dash = 400;
          const jump = ignore ? -100 : (s.r > player.r ? 160 : -100);
          s.x += (player.x - s.x) / d * jump; s.y += (player.y - s.y) / d * jump;
        }
        glow(s.x, s.y, s.r, '#ff39ff', 0.9);
      });

      if (spectreKill >= 6) {
        while (reapers.length < Math.min(REAPER_MAX, BASE_REAPER_COUNT + Math.floor(spectreKill / 15))) spawnReaper();
      }
      reapers.forEach((r, i) => {
        if (!onScreen(r.x, r.y, r.r)) return;
        r.charge -= dt;
        const d = dist(player.x, player.y, r.x, r.y),
              ignore = player.mass < SAFE_PLAYER_MASS;
        if (d > 2400) { reapers.splice(i, 1); return; }
        if (!ignore && d < player.r) {
          player.mass += r.r;
          player.colorEffect = { color: '#ff8800', t: 500 };
          reapers.splice(i, 1);
          burst(r.x, r.y, '#ff8800');
          return;
        }
        if (!ignore && !shieldActive && d < r.r && r.r > player.r) {
          if (player.blink < 50) player.blink = BLINK_MS;
          player.mass = Math.max(5, player.mass - 0.25 * dt);
          document.getElementById('hurtSnd').play().catch(() => {});
        }
        if (r.charge <= 0) {
          r.charge = 300;
          const step = ignore ? -100 : (r.r > player.r ? 130 : -100);
          r.x += (player.x - r.x) / d * step; r.y += (player.y - r.y) / d * step;
        }
        glow(r.x, r.y, r.r, '#ff8800', 0.9);
      });

      if (pill.active && dist(player.x, player.y, pill.x, pill.y) < player.r + pill.r) {
        player.colorEffect = { color: '#00aaff', t: 500 };
        frenzy = true; F_TIME = 10000; pill.active = false;
        document.getElementById('frenzySnd').play().catch(() => {});
        for (let i = 0; i < 40; i++) {
          const a = Math.random() * Math.PI * 2,
                R = 120 + Math.random() * 120;
          food.push({
            cx: player.x, cy: player.y, ang: a, baseR: R, angV: .004 + Math.random() * .003,
            x: player.x + Math.cos(a) * R, y: player.y + Math.sin(a) * R,
            r: 5, frenzy: true, col: '#ff39ff'
          });
        }
      }
      if (frenzy) {
        F_TIME -= dt; if (F_TIME <= 0) {
          frenzy = false; food.forEach(f => f.frenzy = false);
        }
      }
      food.forEach(f => { if (f.frenzy) {
        f.ang += f.angV * dt;
        f.x = f.cx + Math.cos(f.ang) * f.baseR;
        f.y = f.cy + Math.sin(f.ang) * f.baseR;
      }});
      if (!pill.active && !frenzy) {
        pill.cd += dt;
        if (pill.cd > 25000 + Math.random() * 10000) spawnPill();
      }
      if (pill.active) glow(pill.x, pill.y, pill.r, '#00aaff', 0.9);

      if (shield.active && dist(player.x, player.y, shield.x, shield.y) < player.r + shield.r) {
        player.colorEffect = { color: '#ffd700', t: 500 };
        shieldActive = true;
        shieldTime = SHIELD_DURATION;
        shield.active = false;
        document.getElementById('eatSnd').play().catch(() => {});
      }
      if (shieldActive) {
        shieldTime -= dt;
        if (shieldTime <= 0) shieldActive = false;
      }
      if (!shield.active && !shieldActive) {
        shield.cd += dt;
        if (shield.cd > 30000 + Math.random() * 15000) spawnShield();
      }
      if (shield.active) glow(shield.x, shield.y, shield.r, '#ffd700', 0.9);

      beacons.forEach((b, i) => {
        if (!onScreen(b.x, b.y, b.r)) return;
        if (dist(player.x, player.y, b.x, b.y) < player.r + b.r) {
          beacons.length = 0; radarActive = true;
          document.getElementById('radarWrap').style.display = 'block';
        }
        glow(b.x, b.y, b.r, '#fff', 0.5);
      });

      player.r = 10 + player.mass / 15;
      level = Math.floor(player.mass / 100) + 1;
      player.tail.unshift({ x: player.x, y: player.y });
      while (player.tail.length > Math.ceil(player.mass / 3 * (1 + EXTRA_TAIL_PCT))) {
        player.tail.pop();
      }
      if (player.blink > 0) player.blink -= dt;

      const skipTail = Math.max(1, Math.ceil(player.tail.length / MAX_TAIL_DRAW));
      for (let i = 0; i < player.tail.length; i += skipTail) {
        const p = player.tail[i];
        glow(p.x, p.y, player.r * (1 - i / player.tail.length),
             mix('#00e4b8', '#ff39ff', i / player.tail.length), 0.3);
      }

      for (let i = 0; i < 3; i++) {
        const ang = Math.random() * Math.PI * 2,
              rd = player.r * (0.8 + Math.random() * 0.4);
        headParticles.push({
          x: player.x + Math.cos(ang) * rd,
          y: player.y + Math.sin(ang) * rd,
          dx: (Math.random() - 0.5) * 0.5, dy: (Math.random() - 0.5) * 0.5,
          r: 1 + Math.random() * 1.5, ttl: 30 + Math.random() * 30
        });
      }
      particles.forEach((p, i) => {
        p.x += p.dx;
        p.y += p.dy;
        p.ttl--;
        ctx.globalAlpha = p.ttl / (p.shape === 'circle' ? 60 : 80);
        ctx.fillStyle = p.col;
        ctx.beginPath();
        if (p.shape === 'circle') {
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        } else {
          ctx.rect(p.x - p.r, p.y - p.r, p.r * 2, p.r * 2);
        }
        ctx.fill();
        ctx.globalAlpha = 1;
        if (p.ttl <= 0) particles.splice(i, 1);
      });

      for (let i = 0; i < 2; i++) {
        const ang = Math.random() * Math.PI * 2,
              dist = player.r * (1 + Math.random() * 0.5);
        playerAuraParticles.push({
          x: player.x + Math.cos(ang) * dist,
          y: player.y + Math.sin(ang) * dist,
          ang: ang,
          dist: dist,
          angV: 0.01 + Math.random() * 0.02,
          r: 1 + Math.random() * 1,
          ttl: 500 + Math.random() * 500,
          col: '#00e4b8'
        });
      }
      playerAuraParticles.forEach((p, i) => {
        p.ang += p.angV * dt;
        p.x = player.x + Math.cos(p.ang) * p.dist;
        p.y = player.y + Math.sin(p.ang) * p.dist;
        p.ttl -= dt;
        glow(p.x, p.y, p.r, p.col, p.ttl / 1000);
        if (p.ttl <= 0) playerAuraParticles.splice(i, 1);
      });

      glow(
        player.x, player.y, player.r,
        player.blink > 0 ? (player.blink % 200 < 100 ? '#fff' : '#ff44ff') : (player.colorEffect.t > 0 ? player.colorEffect.color : '#00e4b8'),
        1,
        20 * zoom
      );

      massEl.textContent = player.mass.toFixed(0);
      scoreEl.textContent = Math.floor(player.mass * 10);
      levelEl.textContent = level;

      if (radarActive) drawRadar();
      drawJoystick();

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>