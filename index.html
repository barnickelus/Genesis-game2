<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Genesis Evolution â€” Headless Final Build</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000; /* Dark space background */
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    display: block;
  }
  #fps {
    position: absolute;
    top: 8px;
    left: 8px;
    color: #0f0;
    font: 12px monospace;
    background: rgba(0,0,0,0.4);
    padding: 2px 4px;
    border-radius: 3px;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="fps">FPS: 0</div>
<script>
// =======================
// Setup & Globals
// =======================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = window.innerWidth;
let H = window.innerHeight;
canvas.width = W;
canvas.height = H;

window.addEventListener('resize', () => {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
});

// Utility: convert degrees to radians
const toRad = angle => angle * Math.PI / 180;

// =======================
// Color Cycling
// =======================
let hue = 200; // start color
function updateHue(speed=0.2) {
  hue += speed;
  if (hue > 360) hue -= 360;
}

// =======================
// Player Object
// =======================
let player = {
  x: W/2,
  y: H/2,
  size: 15,
  tail: [],
  tailLength: 20,
  speed: 4,
  growth: 0,
  vx: 0,
  vy: 0,
  pulse: 0
};

// =======================
// Drag Control
// =======================
let touchX = player.x, touchY = player.y;
canvas.addEventListener('touchmove', e => {
  const t = e.touches[0];
  touchX = t.clientX;
  touchY = t.clientY;
});

// =======================
// Tail & Particle Systems
// =======================
let particles = [];
let afterimages = [];

function spawnParticle(x, y, color) {
  particles.push({
    x, y,
    vx: (Math.random()-0.5)*2,
    vy: (Math.random()-0.5)*2,
    life: 1,
    color
  });
}

// =======================
// FPS Counter
// =======================
let lastTime = performance.now();
let frameCount = 0;
let fps = 0;
const fpsDisplay = document.getElementById('fps');

// =======================
// Background Grid
// =======================
function drawGrid() {
  ctx.save();
  ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.3)`;
  ctx.lineWidth = 1;

  const spacing = 50;
  const offsetX = (player.x % spacing);
  const offsetY = (player.y % spacing);

  // Vertical lines
  for (let x = -offsetX; x < W; x += spacing) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }
  // Horizontal lines
  for (let y = -offsetY; y < H; y += spacing) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }
  ctx.restore();
}

// =======================
// Game Loop
// =======================
function update(dt) {
  // Smooth movement toward touch point
  let dx = touchX - player.x;
  let dy = touchY - player.y;
  player.vx = dx * 0.1;
  player.vy = dy * 0.1;
  player.x += player.vx;
  player.y += player.vy;

  // Tail positions
  player.tail.unshift({x: player.x, y: player.y});
  if (player.tail.length > player.tailLength) player.tail.pop();

  // Animate pulse
  player.pulse += dt * 0.005;

  // Update particles
  for (let p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.02;
  }
  particles = particles.filter(p => p.life > 0);

  // Afterimages
  afterimages.push({tail: [...player.tail], life: 0.5});
  afterimages.forEach(ai => ai.life -= 0.01);
  afterimages = afterimages.filter(ai => ai.life > 0);

  // Color cycle
  updateHue(0.3);
}

function draw() {
  ctx.clearRect(0,0,W,H);

  // Draw background grid
  drawGrid();

  // Draw afterimages
  for (let ai of afterimages) {
    ctx.globalAlpha = ai.life * 0.3;
    ctx.strokeStyle = `hsl(${hue}, 100%, 60%)`;
    ctx.beginPath();
    for (let i = 0; i < ai.tail.length; i++) {
      const t = ai.tail[i];
      if (i === 0) ctx.moveTo(t.x, t.y);
      else ctx.lineTo(t.x, t.y);
    }
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Draw tail
  ctx.strokeStyle = `hsl(${hue}, 100%, 60%)`;
  ctx.lineWidth = player.size / 3;
  ctx.beginPath();
  for (let i = 0; i < player.tail.length; i++) {
    const t = player.tail[i];
    if (i === 0) ctx.moveTo(t.x, t.y);
    else ctx.lineTo(t.x, t.y);
  }
  ctx.stroke();

  // Draw player core
  const pulseSize = Math.sin(player.pulse) * 2;
  ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size + pulseSize, 0, Math.PI*2);
  ctx.fill();

  // Draw particles
  for (let p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function loop(timestamp) {
  const dt = timestamp - lastTime;
  lastTime = timestamp;

  frameCount++;
  if (frameCount >= 10) {
    fps = Math.round(1000 / dt);
    fpsDisplay.textContent = `FPS: ${fps}`;
    frameCount = 0;
  }

  update(dt);
  draw();
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>